package provision

import (
	"bytes"
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/pkg/errors"
	"github.com/threefoldtech/zos/pkg/versioned"
)

// ReservationType type
type ReservationType string

const (
	// ContainerReservation type
	ContainerReservation ReservationType = "container"
	// VolumeReservation type
	VolumeReservation ReservationType = "volume"
	// NetworkReservation type
	NetworkReservation ReservationType = "network"
	// ZDBReservation type
	ZDBReservation ReservationType = "zdb"
	// DebugReservation type
	DebugReservation ReservationType = "debug"
)

var (
	// reservationSchemaV1 reservation schema version 1
	reservationSchemaV1 = versioned.MustParse("1.0.0")
	// reservationSchemaLastVersion link to latest version
	reservationSchemaLastVersion = reservationSchemaV1
)

// Reservation struct
type Reservation struct {
	// ID of the reservation
	ID string `json:"id"`
	// Identification of the user requesting the reservation
	User string `json:"user_id"`
	// Type of the reservation (container, zdb, vm, etc...)
	Type ReservationType `json:"type"`
	// Data is the reservation type arguments.
	Data json.RawMessage `json:"data,omitempty"`
	// Date of creation
	Created time.Time `json:"created"`
	// Duration of the reservation
	Duration time.Duration `json:"duration"`
	// Signature is the signature to the reservation
	// it contains all the field of this struct except the signature itself and the Result field
	Signature []byte `json:"signature,omitempty"`

	// This flag is set to true when a reservation needs to be deleted
	// before its expiration time
	ToDelete bool `json:"to_delete"`

	// Tag object is mainly used for debugging.
	Tag Tag `json:"-"`
}

// AppendTag appends tags
func AppendTag(t, n Tag) Tag {
	if t == nil {
		t = Tag{}
	}

	for k, v := range n {
		t[k] = v
	}

	return t
}

// Tag is custom tag to mark certain reservations
type Tag map[string]string

func (t Tag) String() string {
	var builder strings.Builder
	for k, v := range t {
		if builder.Len() != 0 {
			builder.WriteString(", ")
		}
		builder.WriteString(k)
		builder.WriteString(": ")
		builder.WriteString(v)
	}

	return builder.String()
}

//SplitID gets the reservation part and the workload part from a full reservation ID
func (r *Reservation) SplitID() (reservation uint64, workload uint64, err error) {
	parts := strings.SplitN(r.ID, "-", 2)
	if len(parts) != 2 {
		return reservation, workload, fmt.Errorf("invalid reservation id format (wront length)")
	}
	reservation, err = strconv.ParseUint(parts[0], 10, 64)
	if err != nil {
		return reservation, workload, errors.Wrap(err, "invalid reservation id format (reservation part)")
	}
	workload, err = strconv.ParseUint(parts[1], 10, 64)
	if err != nil {
		return reservation, workload, errors.Wrap(err, "invalid reservation id format (workload part)")
	}

	return
}

// Expired returns a boolean depending if the reservation
// has expire or not at the time of the function call
func (r *Reservation) Expired() bool {
	expire := r.Created.Add(r.Duration)
	return time.Now().After(expire)
}

func (r *Reservation) validate() error {
	// TODO: during testnet phase seems we don't need to verify this
	// if err := Verify(r); err != nil {
	// 	log.Warn().
	// 		Err(err).
	// 		Str("id", string(r.ID)).
	// 		Msg("verification of reservation signature failed")
	// 	return errors.Wrapf(err, "verification of reservation %s signature failed", r.ID)
	// }

	if r.Duration <= 0 {
		return fmt.Errorf("reservation %s has not duration", r.ID)
	}

	if r.Created.IsZero() {
		return fmt.Errorf("wrong creation date in reservation %s", r.ID)
	}

	if r.Expired() {
		return fmt.Errorf("reservation %s has expired", r.ID)
	}

	return nil
}

// Result is the struct filled by the node
// after a reservation object has been processed
type Result struct {
	Type ReservationType `json:"type"`
	//Reservation ID
	ID string `json:"id"`
	// Time when the result is sent
	Created time.Time `json:"created"`
	// State of the deployment (ok,error)
	State string `json:"state"`
	// if State is "error", then this field contains the error
	// otherwise it's nil
	Error string `json:"error"`
	// Data is the information generated by the provisioning of the workload
	// its type depend on the reservation type
	Data json.RawMessage `json:"data"`
	// Signature is the signature to the result
	// it contains all the field of this struct except the signature itself
	Signature []byte `json:"signature"`
}

// Bytes returns a slice of bytes container all the information
// used to sign the Result object
func (r *Result) Bytes() ([]byte, error) {
	buf := &bytes.Buffer{}
	var err error

	if r.Error != "=" {
		_, err = buf.WriteString(r.Error)
	} else {
		_, err = buf.WriteString("")
	}
	if err != nil {
		return nil, err
	}

	_, err = buf.Write(r.Data)
	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}
